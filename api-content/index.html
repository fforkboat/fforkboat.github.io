{"posts":[{"title":"二分查找的正确写法","content":"想要写好一个二分查找的算法，重点在于思考清楚left和right所表示的含义，并且在while循环中更新它们时不能改变它们的含义（其实就是循环不变式的特性）。 拿最简单的场景举个例子：从一个有序数组中查找一个值的索引，如果没有这个值，就返回-1 在这道题目中，我最喜欢的做法是： 令left和right分别表示搜索空间的下界和上界，我们要找的值只可能存在于[left, right]这个区间中，那么只要left &lt;= right，就表示这个区间中还有元素，我们就需要继续搜索，那么while循环的条件应该是while (left &lt;= right)。而left和right的初值自然分别是0和length-1 当values[mid] &gt; target时，易得target元素只可能出现在[left, mid - 1]中，所以为了继续维持right的下界含义，我们应该令right = mid - 1。 当values[mid] &lt; target时，易得target元素只可能出现在[mid + 1, right]中，同理，我们应该令left = mid + 1。 当values[mid] == target时，直接返回mid。 如果循环退出，表示已经没有元素可以搜索了，而此时还没有找到target的话就永远找不到了，所以应该返回-1 再举个复杂点的例子：从一个有序数组中找到第一个大于或者等于target的值的索引 此时，我喜欢的做法是： 同样的，维护一个区间[left, right]，我们要找的元素只可能存在于[left, right]之间，在while循环的内部，不断更新left和right的值，直到区间的长度为1时退出，此时判断区间中唯一的元素是不是我们要找的值。 令left和right的初始值分别为0, length - 1，循环的条件是while(left &lt; right) 当values[mid] &gt; target，right = mid - 1 当values[mid] &lt; target，left = mid + 1 当values[mid] == target，因为我们要找第一个符合条件的值，此时它只可能存在于[left, mid]中，所以我们令right = mid 但是要注意的是，如果要找的是最后一个等于target的值的索引，那么当values[mid] == target时，按理说符合条件的值只可能出现在[mid, right]中，那么我们应该令left = mid，但是当区间中只有两个元素，即right = left + 1时，left已经是等于mid的了，如果还这样赋值的话就永远无法退出循环，因此需要特殊处理一下。 上面这个例子还有另外一种解法： 此时left, right表示的意义和上面的不同。left表示一个索引，它可能就是我们所需要寻找的目标索引，当left还可能被更新到一个更大的值时才继续循环，我们令right为这样的一个屏障，当left &lt;= right时，left才有可能继续更新、才能够继续循环。 那么left的初值为0，right的初值为length-1，循环条件为while(left &lt; right) 当values[mid] &lt; target时，left可以被更新到mid + 1 当values[mid] &gt; target时，right可以被更新到mid - 1 当values[mid] == target时，left只有在left &lt;= mid-1时，才可能更新到一个更大的值（即mid），所以right应该被更新为mid - 1 这种解法代码写起来容易一点，但是要搞清left和right的真实含义就有点困难了，有时或许你写的是对的，但是其实你并不是真的明白它为什么是对的。 ","link":"https://fforkboat.github.io/post/er-fen-cha-zhao-de-zheng-que-xie-fa/"},{"title":"select、poll、epoll","content":"select, poll, epoll是Linux提供的三个用于IO多路复用的系统调用，被封装在C函数中 select 在传统的网络编程中，我们为每一个连接分配一个线程，当并发连接达到一定数量时，线程占用的空间会超出存储空间的限制。在基于IO多路复用的新式架构下，我们可以使用一个或者很少数量的线程来管理连接，来监控所有socket的可读写状态，select可以同时监控多个文件描述符的状态，一旦发现任意一个描述符准备好了，就立即返回，并通知应用程序。 select的问题在于: 能够传入select的socket数组容量有限，只有1024个；这一点在poll中被解决了(poll也只改进了这一点) 每一次调用都需要传入感兴趣的文件描述符数组，这个数组会被复制到内核空间中，内核每次都需要扫描和分析它们，文件描述符的数量越多，复制和处理花的时间也就越长，所以它们的工作效率和可拓展性不是很好。 只要有一个socket可读了，所有的socket都会被扫描一遍来收集它们的可读信息 epoll 对于select的问题2，epoll的解决方法是： 提供三个函数，分别用于创建一个类似session的东西、向session传递文件描述符、阻塞的监控多个文件描述符。也就是说我们的FD（文件描述符）只需要传递和分析一次，以后只需要指定session的号码就行了。 对于问题3： epoll中添加了一个read list，用于存放可读的socket，当线程被唤醒后只需要遍历这个read list就可以了。 参考资料 https://cloud.tencent.com/developer/article/1005481 ","link":"https://fforkboat.github.io/post/selectpollepoll/"},{"title":"MD5","content":"MD5是一种算法，可以对任意长度的输入计算一个固定长度（16个字节）的输出，常用于加密、数字签名。 用途 密码管理 当我们需要保存某些密码信息以用于身份确认时，如果直接将密码信息以明码方式保存在数据库中，不使用任何保密措施，系统管理员就很容易能得到原来的密码信息，这些信息一旦泄露， 密码也很容易被破译。为了增加安全性，有必要对数据库中需要保密的信息进行加密，这样，即使有人得到了整个数据库，如果没有解密算法，也不能得到原来的密码信息。MD5算法可以很好地解决这个问题，因为它可以将任意长度的输入串经过计算得到固定长度的输出，而且只有在明文相同的情况下，才能等到相同的密文，并且这个算法是不可逆的，即便得到了加密以后的密文，也不可能通过解密算法反算出明文。这样就可以把用户的密码以MD5值（或类似的其它算法）的方式保存起来，用户注册的时候，系统是把用户输入的密码计算成 MD5 值，然后再去和系统中保存的 MD5 值进行比较，如果密文相同，就可以认定密码是正确的，否则密码错误。通过这样的步骤，系统在并不知道用户密码明码的情况下就可以确定用户登录系统的合法性。这样不但可以避免用户的密码被具有系统管理员权限的用户知道，而且还在一定程度上增加了密码被破解的难度 。 电子签名 MD5 算法还可以作为一种电子签名的方法来使用，使用 MD5算法就可以为任何文件（不管其大小、格式、数量）产生一个独一无二的“数字指纹”，借助这个“数字指纹”，通过检查文件前后 MD5 值是否发生了改变，就可以知道源文件是否被改动。我们在下载软件的时候经常会发现，软件的下载页面上除了会提供软件的下载地址以外，还会给出一串长长的字符串。这串字符串其实就是该软件的MD5 值，它的作用就在于下载该软件后，对下载得到的文件用专门的软件（如 Windows MD5 check 等）做一次 MD5 校验，以确保我们获得的文件与该站点提供的文件为同一文件。利用 MD5 算法来进行文件校验的方案被大量应用到软件下载站、论坛数据库、系统文件安全等方面 。 ","link":"https://fforkboat.github.io/post/md5/"},{"title":"B树和B+树","content":"B树和B+树都是一种常用于磁盘索引的数据结构，它们的本质是多路平衡搜索树。相比于二叉搜索树，它们的每个节点可以存储更多的关键词，因此它们的整体结构会更加的矮胖，同时，多关键词的节点能够让它们在搜索的过程中减少磁盘IO的次数，提高搜索的性能。 二者的区别 B树和二叉搜索树比较类似，每个节点既需要保存索引值，又需要保存索引所在的数据行信息。而在B+树中，中间节点只会保存索引值，并且这些索引值都出现在子节点中，是子节点的最大（或最小）元素，因此叶子节点中会保存所有的索引值，除此之外，叶子节点还会保存索引所在的数据行信息。聚簇索引中直接保存行数据内容，而非聚簇索引中保存指向行的指针。 B+树的叶子节点会指向下一个叶子节点，整体上形成一个列表，在这个链表上，索引值从小到大顺序排布。这样的结构非常适合获取有序的结果集，并且获取范围数据只需要遍历链表就可以了，而在B树上需要先找到范围下界索引，再进行中序遍历找到范围上界索引。 总结起来，B+树的优势在于： IO次数更少：因为中间节点不需要保存行数据，可以存储更多的索引值 查询性能稳定：每次都需要遍历到叶子节点，而B树可能在中间就停下了 范围查找更加方便 ","link":"https://fforkboat.github.io/post/b-shu-he-bshu/"},{"title":"Golang: GOPATH、package、module","content":"GOPATH GOPATH是Go工作区的路径，工作区内包含了三个文件夹： bin: 存放 Go install命令编译得到的可执行文件 pkg: 存放编译好的目标文件 src: 存放源代码 我们可以同时指定多个GOPATH，以此获得多个工作区，Go build等命令会考虑所有的工作区 package package(包)是在同一目录下的多个.go文件的集合。任何一个.go文件的第一行都会说明这个.go文件的package名，在同一个文件目录下的.go文件必须具有相同的package名，并且package名建议（但是不强制）和文件的目录名相同。 注意，这里说“同一个文件目录下的.go文件必须具有相同的package名”是考虑将这一个文件目录当作一个包来使用的，我们会编译这个包，或者在其他地方引用这个包。但是如果你是出于练习玩耍的目的，当然是可以把具有不同package名的.go文件放在同一个目录下的，此时这个目录就没有包的语义了，它就只是一个存放文件的地方。 import和go build 我们在一个go文件中可以直接使用同一个包中的public成员，当需要使用其他包中的成员时，就需要用到import语句。在非module模式下，import关键词后面跟着的是一个相对于$GOPATH/src的路径，这个路径的最后一个部分是一个目录，Go将会引入这个目录对应的包。比如import github.com/foo/bar/tools这条命令会引入tools这个目录对应的包，一般来说，这个包的名字和目录的名字相同，在这里也就是tools，接下来我们可以使用tools.Xxx来访问tools包中的成员。但是包的名字也可以和目录不同，如果tools目录下的.go文件的package名都为weird的话，那么我们就需要使用weird.Xxx来访问weird包的成员，这很容易让人感到疑惑，所以最好令包的名字和目录的名字相同。 go build有三种工作模式： go build go_file: 编译一个.go文件 go build .: 编译当前目录（不考虑子目录）的所有.go文件 go buid path_to_package: 编译一个package（不考虑子package）的所有.go文件，这个package可以通过$GOPATH/src/path_to_package来找到 module module(模块)是Go 1.11引入的一个新的概念，一个模块是一些包的集合，这些包以树状模式组织。 我们通过go mod init [module_name]来创建一个模块，这条命令会在当前目录下创建一个go.mod文件，这个文件向go标识当前目录（和它的子目录）构成了一个模块。 在go.mod文件中我们可以写明该模块依赖的其他模块，然后通过go mod download命令来将这些模块下载到本地的缓存中，下载的位置不再是$GOPATH/src了，而是$GOPATH/pkg/mod。 在module模式下，import的规则发生了变化，import后面接着的不再是相对于$GOPATH/src的路径，而是[module_name]/path/to/package举个例子，考虑下面的模块结构，假设go.mod中规定的模块名为example.com/my/a_repo： 那我们在pkg1.go中引用pkg2包需要使用import example.com/my/a_repo/pkg2，引用Dragonboat 3.0中的config包需要使用import github.com/lni/dragonboat/v3/config 在module模块下，go build path_to_package也发生了变化，和import规则一样，我们需要转为使用go build [module_name]/path/to/package。比如我们编译上图中的pkg2，则命令为: go build example.com/my/a_repo/pkg2 ","link":"https://fforkboat.github.io/post/golang-gopathpackagemodule/"}]}