{"posts":[{"title":"Golang: GOPATH、package、module","content":"GOPATH GOPATH是Go工作区的路径，工作区内包含了三个文件夹： bin: 存放 Go install命令编译得到的可执行文件 pkg: 存放编译好的目标文件 src: 存放源代码 我们可以同时指定多个GOPATH，以此获得多个工作区，Go build等命令会考虑所有的工作区 package package(包)是在同一目录下的多个.go文件的集合。任何一个.go文件的第一行都会说明这个.go文件的package名，在同一个文件目录下的.go文件必须具有相同的package名，并且package名建议（但是不强制）和文件的目录名相同。 注意，这里说“同一个文件目录下的.go文件必须具有相同的package名”是考虑将这一个文件目录当作一个包来使用的，我们会编译这个包，或者在其他地方引用这个包。但是如果你是出于练习玩耍的目的，当然是可以把具有不同package名的.go文件放在同一个目录下的，此时这个目录就没有包的语义了，它就只是一个存放文件的地方。 import和go build 我们在一个go文件中可以直接使用同一个包中的public成员，当需要使用其他包中的成员时，就需要用到import语句。在非module模式下，import关键词后面跟着的是一个相对于$GOPATH/src的路径，这个路径的最后一个部分是一个目录，Go将会引入这个目录对应的包。比如import github.com/foo/bar/tools这条命令会引入tools这个目录对应的包，一般来说，这个包的名字和目录的名字相同，在这里也就是tools，接下来我们可以使用tools.Xxx来访问tools包中的成员。但是包的名字也可以和目录不同，如果tools目录下的.go文件的package名都为weird的话，那么我们就需要使用weird.Xxx来访问weird包的成员，这很容易让人感到疑惑，所以最好令包的名字和目录的名字相同。 go build有三种工作模式： go build go_file: 编译一个.go文件 go build .: 编译当前目录（不考虑子目录）的所有.go文件 go buid path_to_package: 编译一个package（不考虑子package）的所有.go文件，这个package可以通过$GOPATH/src/path_to_package来找到 module module(模块)是Go 1.11引入的一个新的概念，一个模块是一些包的集合，这些包以树状模式组织。 我们通过go mod init [module_name]来创建一个模块，这条命令会在当前目录下创建一个go.mod文件，这个文件向go标识当前目录（和它的子目录）构成了一个模块。 在go.mod文件中我们可以写明该模块依赖的其他模块，然后通过go mod download命令来将这些模块下载到本地的缓存中，下载的位置不再是GOPATH/src了，而是GOPATH/src了，而是GOPATH/src了，而是GOPATH/pkg/mod。 在module模式下，import的规则发生了变化，import后面接着的不再是相对于$GOPATH/src的路径，而是[module_name]/path/to/package举个例子，考虑下面的模块结构，假设go.mod中规定的模块名为example.com/my/a_repo： 那我们在pkg1.go中引用pkg2包需要使用import example.com/my/a_repo/pkg2，引用Dragonboat 3.0中的config包需要使用import github.com/lni/dragonboat/v3/config 在module模块下，go build path_to_package也发生了变化，和import规则一样，我们需要转为使用go build [module_name]/path/to/package。比如我们编译上图中的pkg2，则命令为: go build example.com/my/a_repo/pkg2 ","link":"https://fforkboat.github.io/post/golang-gopathpackagemodule/"}]}