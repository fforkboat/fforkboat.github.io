<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://fforkboat.github.io</id>
    <title>fforkboat&apos;s dock</title>
    <updated>2020-08-21T10:19:44.149Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://fforkboat.github.io"/>
    <link rel="self" href="https://fforkboat.github.io/atom.xml"/>
    <subtitle>福柯船长的船坞</subtitle>
    <logo>https://fforkboat.github.io/images/avatar.png</logo>
    <icon>https://fforkboat.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, fforkboat&apos;s dock</rights>
    <entry>
        <title type="html"><![CDATA[B树和B+树]]></title>
        <id>https://fforkboat.github.io/post/b-shu-he-bshu/</id>
        <link href="https://fforkboat.github.io/post/b-shu-he-bshu/">
        </link>
        <updated>2020-08-21T10:18:18.000Z</updated>
        <content type="html"><![CDATA[<p>B树和B+树都是一种常用于磁盘索引的数据结构，它们的本质是多路平衡搜索树。相比于二叉搜索树，它们的每个节点可以存储更多的关键词，因此它们的整体结构会更加的矮胖，同时，多关键词的节点能够让它们在搜索的过程中减少磁盘IO的次数，提高搜索的性能。</p>
<h2 id="二者的区别">二者的区别</h2>
<p>B树和二叉搜索树比较类似，每个节点既需要保存索引值，又需要保存索引所在的数据行信息。而在B+树中，中间节点只会保存索引值，并且这些索引值都出现在子节点中，是子节点的最大（或最小）元素，因此叶子节点中会保存所有的索引值，除此之外，叶子节点还会保存索引所在的数据行信息。聚簇索引中直接保存行数据内容，而非聚簇索引中保存指向行的指针。</p>
<p>B+树的叶子节点会指向下一个叶子节点，整体上形成一个列表，在这个链表上，索引值从小到大顺序排布。这样的结构非常适合获取有序的结果集，并且获取范围数据只需要遍历链表就可以了，而在B树上需要先找到范围下界索引，再进行中序遍历找到范围上界索引。</p>
<p>总结起来，B+树的优势在于：</p>
<ol>
<li>IO次数更少：因为中间节点不需要保存行数据，可以存储更多的索引值</li>
<li>查询性能稳定：每次都需要遍历到叶子节点，而B树可能在中间就停下了</li>
<li>范围查找更加方便</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Golang: GOPATH、package、module]]></title>
        <id>https://fforkboat.github.io/post/golang-gopathpackagemodule/</id>
        <link href="https://fforkboat.github.io/post/golang-gopathpackagemodule/">
        </link>
        <updated>2020-08-09T14:44:55.000Z</updated>
        <content type="html"><![CDATA[<h2 id="gopath">GOPATH</h2>
<p>GOPATH是Go工作区的路径，工作区内包含了三个文件夹：</p>
<ul>
<li>bin: 存放 <code>Go install</code>命令编译得到的可执行文件</li>
<li>pkg: 存放编译好的目标文件</li>
<li>src: 存放源代码</li>
</ul>
<p>我们可以同时指定多个GOPATH，以此获得多个工作区，Go build等命令会考虑所有的工作区</p>
<h2 id="package">package</h2>
<p>package(包)是在同一目录下的多个.go文件的集合。任何一个.go文件的第一行都会说明这个.go文件的package名，在同一个文件目录下的.go文件必须具有相同的package名，并且package名建议（但是不强制）和文件的目录名相同。</p>
<blockquote>
<p>注意，这里说“同一个文件目录下的.go文件必须具有相同的package名”是考虑将这一个文件目录当作一个包来使用的，我们会编译这个包，或者在其他地方引用这个包。但是如果你是出于练习玩耍的目的，当然是可以把具有不同package名的.go文件放在同一个目录下的，此时这个目录就没有包的语义了，它就只是一个存放文件的地方。</p>
</blockquote>
<h3 id="import和go-build">import和go build</h3>
<p>我们在一个go文件中可以直接使用同一个包中的public成员，当需要使用其他包中的成员时，就需要用到import语句。在非module模式下，import关键词后面跟着的是一个相对于<code>$GOPATH/src</code>的路径，这个路径的最后一个部分是一个目录，Go将会引入这个目录对应的包。比如<code>import github.com/foo/bar/tools</code>这条命令会引入tools这个目录对应的包，一般来说，这个包的名字和目录的名字相同，在这里也就是<code>tools</code>，接下来我们可以使用<code>tools.Xxx</code>来访问<code>tools</code>包中的成员。但是包的名字也可以和目录不同，如果tools目录下的.go文件的package名都为<code>weird</code>的话，那么我们就需要使用<code>weird.Xxx</code>来访问<code>weird</code>包的成员，这很容易让人感到疑惑，所以最好令包的名字和目录的名字相同。</p>
<p>go build有三种工作模式：</p>
<ol>
<li><code>go build go_file</code>: 编译一个.go文件</li>
<li><code>go build .</code>: 编译当前目录（不考虑子目录）的所有.go文件</li>
<li><code>go buid path_to_package</code>: 编译一个package（不考虑子package）的所有.go文件，这个package可以通过$GOPATH/src/path_to_package来找到</li>
</ol>
<h2 id="module">module</h2>
<p>module(模块)是Go 1.11引入的一个新的概念，一个模块是一些包的集合，这些包以树状模式组织。</p>
<p>我们通过<code>go mod init [module_name]</code>来创建一个模块，这条命令会在当前目录下创建一个go.mod文件，这个文件向go标识当前目录（和它的子目录）构成了一个模块。</p>
<p>在go.mod文件中我们可以写明该模块依赖的其他模块，然后通过go mod download命令来将这些模块下载到本地的缓存中，下载的位置不再是<code>$GOPATH/src</code>了，而是<code>$GOPATH/pkg/mod</code>。</p>
<p>在module模式下，import的规则发生了变化，import后面接着的不再是相对于<code>$GOPATH/src</code>的路径，而是<code>[module_name]/path/to/package</code>举个例子，考虑下面的模块结构，假设go.mod中规定的模块名为<code>example.com/my/a_repo</code>：</p>
<figure data-type="image" tabindex="1"><img src="https://fforkboat-markdown-img.oss-cn-hongkong.aliyuncs.com/imgimage-20200804164456186.png" alt="image-20200804164456186" loading="lazy"></figure>
<p>那我们在pkg1.go中引用pkg2包需要使用<code>import example.com/my/a_repo/pkg2</code>，引用Dragonboat 3.0中的config包需要使用<code>import github.com/lni/dragonboat/v3/config</code></p>
<p>在module模块下，<code>go build path_to_package</code>也发生了变化，和import规则一样，我们需要转为使用<code>go build [module_name]/path/to/package</code>。比如我们编译上图中的pkg2，则命令为: <code>go build example.com/my/a_repo/pkg2</code></p>
]]></content>
    </entry>
</feed>